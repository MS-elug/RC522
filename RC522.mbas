module RC522
' ******************
' INTERFACE GLOBAL
' ******************
  ' Declarations section
  'symbol RC522_SS_PIN = LATC.4
  'symbol RC522_RST_PIN = LATC.4
  

 '########################################################################
 ' MFRC522 registers. Described in chapter 9 of the datasheet.
 ' When using SPI all addresses are shifted one bit left in the "SPI address byte" (section 8.1.2.3)
 ' Page 0: Command and status
 '						  0x00		' reserved for future use
  symbol CommandReg				= 0x01 << 1	' starts and stops command execution
  symbol ComIEnReg				= 0x02 << 1	' enable and disable interrupt request control bits
  symbol DivIEnReg				= 0x03 << 1	' enable and disable interrupt request control bits
  symbol ComIrqReg				= 0x04 << 1	' interrupt request bits
  symbol DivIrqReg				= 0x05 << 1	' interrupt request bits
  symbol ErrorReg				= 0x06 << 1	' error bits showing the error status of the last command executed
  symbol Status1Reg				= 0x07 << 1	' communication status bits
  symbol Status2Reg				= 0x08 << 1	' receiver and transmitter status bits
  symbol FIFODataReg				= 0x09 << 1	' input and output of 64 byte FIFO buffer
  symbol FIFOLevelReg			        = 0x0A << 1	' number of bytes stored in the FIFO buffer
  symbol WaterLevelReg			        = 0x0B << 1	' level for FIFO underflow and overflow warning
  symbol ControlReg				= 0x0C << 1	' miscellaneous control registers
  symbol BitFramingReg			        = 0x0D << 1	' adjustments for bit-oriented frames
  symbol CollReg				= 0x0E << 1	' bit position of the first bit-collision detected on the RF interface
 '						  0x0F		' reserved for future use
  ' Page 1: Command
  ' 						  0x10		' reserved for future use
  symbol ModeReg				= 0x11 << 1	' defines general modes for transmitting and receiving
  symbol TxModeReg				= 0x12 << 1	' defines transmission data rate and framing
  symbol RxModeReg				= 0x13 << 1	' defines reception data rate and framing
  symbol TxControlReg			        = 0x14 << 1	' controls the logical behavior of the antenna driver pins TX1 and TX2
  symbol TxASKReg				= 0x15 << 1	' controls the setting of the transmission modulation
  symbol TxSelReg				= 0x16 << 1	' selects the internal sources for the antenna driver
  symbol RxSelReg				= 0x17 << 1	' selects internal receiver settings
  symbol RxThresholdReg			        = 0x18 << 1	' selects thresholds for the bit decoder
  symbol DemodReg				= 0x19 << 1	' defines demodulator settings
  ' 						  0x1A		' reserved for future use
  ' 						  0x1B		' reserved for future use
  symbol MfTxReg				= 0x1C << 1	' controls some MIFARE communication transmit parameters
  symbol MfRxReg				= 0x1D << 1	' controls some MIFARE communication receive parameters
  ' 						  0x1E		' reserved for future use
  symbol SerialSpeedReg			         = 0x1F << 1	' selects the speed of the serial UART interface

  'Page 2: Configuration
  ' 						  0x20		' reserved for future use
  symbol CRCResultRegH			        = 0x21 << 1	' shows the MSB and LSB values of the CRC calculation
  symbol CRCResultRegL			        = 0x22 << 1
  ' 						  0x23		' reserved for future use
  symbol ModWidthReg				= 0x24 << 1	' controls the ModWidth setting?
  ' 						  0x25		' reserved for future use
  symbol RFCfgReg				= 0x26 << 1	' configures the receiver gain
  symbol GsNReg					= 0x27 << 1	' selects the conductance of the antenna driver pins TX1 and TX2 for modulation
  symbol CWGsPReg				= 0x28 << 1	' defines the conductance of the p-driver output during periods of no modulation
  symbol ModGsPReg				= 0x29 << 1	' defines the conductance of the p-driver output during periods of modulation
  symbol TModeReg				= 0x2A << 1	' defines settings for the internal timer
  symbol TPrescalerReg			        = 0x2B << 1	' the lower 8 bits of the TPrescaler value. The 4 high bits are in TModeReg.
  symbol TReloadRegH				= 0x2C << 1	' defines the 16-bit timer reload value
  symbol TReloadRegL				= 0x2D << 1
  symbol TCounterValueRegH		        = 0x2E << 1	' shows the 16-bit timer value
  symbol TCounterValueRegL		        = 0x2F << 1

  ' Page 3: Test Registers
  ' 						  0x30		' reserved for future use
  symbol TestSel1Reg				= 0x31 << 1	' general test signal configuration
  symbol TestSel2Reg				= 0x32 << 1	' general test signal configuration
  symbol TestPinEnReg			        = 0x33 << 1	' enables pin output driver on pins D1 to D7
  symbol TestPinValueReg			= 0x34 << 1	' defines the values for D1 to D7 when it is used as an I/O bus
  symbol TestBusReg				= 0x35 << 1	' shows the status of the internal test bus
  symbol AutoTestReg				= 0x36 << 1	' controls the digital self-test
  symbol VersionReg				= 0x37 << 1	' shows the software version
  symbol AnalogTestReg			        = 0x38 << 1	' controls the pins AUX1 and AUX2
  symbol TestDAC1Reg				= 0x39 << 1	' defines the test value for TestDAC1
  symbol TestDAC2Reg				= 0x3A << 1	' defines the test value for TestDAC2
  symbol TestADCReg				= 0x3B << 1	' shows the value of ADC I and Q channels

  ' STATUS ##################################################################
  symbol STATUS_OK = 0x00	' Success
  symbol STATUS_ERROR = 0x01	' Error in communication
  symbol STATUS_COLLISION = 0x02' Collission detected
  symbol STATUS_TIMEOUT	= 0x03' Timeout in communication.
  symbol STATUS_NO_ROOM	= 0x04' A buffer is not big enough.
  symbol STATUS_INTERNAL_ERROR	= 0x05'Internal error in the code. Should not happen ;-)
  symbol STATUS_INVALID	= 0x06' Invalid argument.
  symbol STATUS_CRC_WRONG = 0x07' The CRC_A does not match
  symbol STATUS_MIFARE_NACK = 0xff'  A MIFARE PICC responded with NAK.


  ' ##########################################################################
  'The commands used by the PCD to manage communication with several PICCs (ISO 14443-3, Type A, section 6.4)
  symbol PICC_CMD_REQA			= 0x26		'REQuest command, Type A. Invites PICCs in state IDLE to go to READY and prepare for anticollision or selection. 7 bit frame.
  symbol PICC_CMD_WUPA			= 0x52		'Wake-UP command, Type A. Invites PICCs in state IDLE and HALT to go to READY(*) and prepare for anticollision or selection. 7 bit frame.
  symbol PICC_CMD_CT				= 0x88		'Cascade Tag. Not really a command, but used during anti collision.
  symbol PICC_CMD_SEL_CL1		= 0x93		'Anti collision/Select, Cascade Level 1
  symbol PICC_CMD_SEL_CL2		= 0x95		'Anti collision/Select, Cascade Level 2
  symbol PICC_CMD_SEL_CL3		= 0x97		'Anti collision/Select, Cascade Level 3
  symbol PICC_CMD_HLTA			= 0x50		'HaLT command, Type A. Instructs an ACTIVE PICC to go to state HALT.
  symbol PICC_CMD_RATS           = 0xE0     'Request command for Answer To Reset.
		' The commands used for MIFARE Classic (from http://www.mouser.com/ds/2/302/MF1S503x-89574.pdf, Section 9)
		' Use PCD_MFAuthent to authenticate access to a sector, then use these commands to read/write/modify the blocks on the sector.
		' The read/write commands can also be used for MIFARE Ultralight.
  symbol PICC_CMD_MF_AUTH_KEY_A	= 0x60		' Perform authentication with Key A
  symbol PICC_CMD_MF_AUTH_KEY_B	= 0x61		' Perform authentication with Key B
  symbol PICC_CMD_MF_READ		= 0x30		' Reads one 16 byte block from the authenticated sector of the PICC. Also used for MIFARE Ultralight.
  symbol PICC_CMD_MF_WRITE		= 0xA0		' Writes one 16 byte block to the authenticated sector of the PICC. Called "COMPATIBILITY WRITE" for MIFARE Ultralight.
  symbol PICC_CMD_MF_DECREMENT	= 0xC0		' Decrements the contents of a block and stores the result in the internal data register.
  symbol PICC_CMD_MF_INCREMENT	= 0xC1		' Increments the contents of a block and stores the result in the internal data register.
  symbol PICC_CMD_MF_RESTORE		= 0xC2		' Reads the contents of a block into the internal data register.
  symbol PICC_CMD_MF_TRANSFER	= 0xB0		' Writes the contents of the internal data register to a block.
		' The commands used for MIFARE Ultralight (from http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf, Section 8.6)
		' The PICC_CMD_MF_READ and PICC_CMD_MF_WRITE can also be used for MIFARE Ultralight.
  symbol PICC_CMD_UL_WRITE		= 0xA2		' Writes one 4 byte page to the PICC.
		
  dim RC522_SS_PIN as sbit at LATC.0
  dim RC522_SS_PIN_TRIS as sbit at TRISC.0
  dim RC522_RST_PIN as sbit at LATC.1
  dim RC522_RST_PIN_TRIS as sbit at TRISC.1
  
  
  ' Initializes the MFRC522 chip.
  sub procedure PCD_Init
  sub procedure PCD_WriteRegister(dim reg as byte, dim value as byte)
  sub function  PCD_ReadRegister (dim reg as byte) as byte
  sub procedure PCD_ClearRegisterBitMask(dim reg as byte, dim mask as byte)
  sub function PICC_RequestA(dim bufferATQA as ^byte, dim bufferSize as ^byte) as byte
  sub function PICC_REQA_or_WUPA(	dim cmd as byte,dim bufferATQA as ^byte, dim bufferSize as ^byte) as byte
  sub procedure PCD_AntennaOn()
  sub function PICC_IsNewCardPresent() as boolean
implements



  ' Initializes the MFRC522 chip.
  sub procedure PCD_Init()

    RC522_SS_PIN = 1                   ' Release slave
    RC522_SS_PIN_TRIS = 0              ' Set pin as Output
    RC522_RST_PIN = 0                  ' Remove hard reset
    RC522_SS_PIN_TRIS = 0              ' Set pin as Output
    
    ' Reset the chip (safe init)
    RC522_RST_PIN = 0
    Delay_us(2)
    RC522_RST_PIN = 1
    ' // Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the crystal + 37,74µs. Let us be generous: 50ms.
    Delay_ms(50)
      
      
    ' Reset baud rates
    PCD_WriteRegister(TxModeReg, 0x00)
    PCD_WriteRegister(RxModeReg, 0x00)
    ' Reset ModWidthReg
    PCD_WriteRegister(ModWidthReg, 0x26)

    ' When communicating with a PICC we need a timeout if something goes wrong.
    ' f_timer = 13.56 MHz / (2*TPreScaler+1) where TPreScaler = [TPrescaler_Hi:TPrescaler_Lo].
    ' TPrescaler_Hi are the four low bits in TModeReg. TPrescaler_Lo is TPrescalerReg.
    PCD_WriteRegister(TModeReg, 0x80)	' TAuto=1; timer starts automatically at the end of the transmission in all communication modes at all speeds
    PCD_WriteRegister(TPrescalerReg, 0xA9)' TPreScaler = TModeReg[3..0]:TPrescalerReg, ie 0x0A9 = 169 => f_timer=40kHz, ie a timer period of 25µs.
    PCD_WriteRegister(TReloadRegH, 0x03)' Reload timer with 0x3E8 = 1000, ie 25ms before timeout.
    PCD_WriteRegister(TReloadRegL, 0xE8)

    PCD_WriteRegister(TxASKReg, 0x40)' Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting
    PCD_WriteRegister(ModeReg, 0x3D)' Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)
    PCD_AntennaOn()' Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
      
  end sub
  
  sub procedure PCD_WriteRegister(dim reg as byte, dim value as byte)
  	RC522_SS_PIN = 0		' Select slave
	SPI_Write(reg)                  ' MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
	SPI_Write(value)
	RC522_SS_PIN = 1		' Release slave
  end sub
  
  
  sub function  PCD_ReadRegister(dim reg as byte) as byte
      dim value as byte
      RC522_SS_PIN = 0		' Select slave
      SPI_Write(0x80 or reg)     ' MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
      result = SPI_Read(0x00)  '  Read the value back. Send 0 to stop reading.
      RC522_SS_PIN = 1		' Release slave
  end sub
  

' Clears the bits given in mask from register reg.
' reg < The register to update. One of the PCD_Register enums
' mask < The bits to clear.

  sub procedure PCD_ClearRegisterBitMask(dim reg as byte, dim mask as byte)
    dim tmp as byte
    tmp = PCD_ReadRegister(reg)
    PCD_WriteRegister(reg, tmp and (not(mask)))	'clear bit mask
  end sub

' Transmits a REQuest command, Type A. Invites PICCs in state IDLE to go to READY and prepare for anticollision or selection. 7 bit frame.
' Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.
' bufferATQA < The buffer to store the ATQA (Answer to request) in
' bufferSize < Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK.
'
  sub function PICC_RequestA(dim bufferATQA as ^byte, dim bufferSize as ^byte) as byte
   result = PICC_REQA_or_WUPA(PICC_CMD_REQA, bufferATQA, bufferSize)
  end sub
 

  ' Transmits REQA or WUPA commands.
  ' Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.
  '  command < The command to send - PICC_CMD_REQA or PICC_CMD_WUPA
  '  bufferATQA < The buffer to store the ATQA (Answer to request) in
  '  bufferSize < Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK.
  '
   sub function PICC_REQA_or_WUPA(dim cmd as byte,dim bufferATQA as ^byte, dim bufferSize as ^byte) as byte
    	dim validBits as byte
        dim status as byte
	if ((bufferATQA = 0) or (bufferSize^ < 2)) then	'The ATQA response is 2 bytes long.
		result = STATUS_NO_ROOM
		return
        end if

        PCD_ClearRegisterBitMask(CollReg, 0x80) 'ValuesAfterColl=1 => Bits received after collision are cleared.
	validBits = 7			 'For REQA and WUPA we need the short frame format - transmit only 7 bits of the last (and only) byte. TxLastBits = BitFramingReg[2..0]
        status = PCD_TransceiveData(@cmd, 1, bufferATQA, bufferSize, @validBits)
	if (status <> STATUS_OK) then
                result = status
		return
        end if
	if (bufferSize^ <> 2 or validBits <> 0) then 'ATQA must be exactly 16 bits.
		result = STATUS_ERROR
		return
        end if
	result = STATUS_OK;
  end sub

'
' Turns the antenna on by enabling pins TX1 and TX2.
' After a reset these pins are disabled.
  sub procedure PCD_AntennaOn()
    dim value as byte
    value = PCD_ReadRegister(TxControlReg)
    if ((value and 0x03) <> 0x03) then
       PCD_WriteRegister(TxControlReg, value or 0x03)
    end if
  end sub
  

  ' Returns true if a PICC responds to PICC_CMD_REQA.
  ' Only "new" cards in state IDLE are invited. Sleeping cards in state HALT are ignored.

  sub function PICC_IsNewCardPresent() as boolean
    dim bufferSize as byte
    dim bufferATQA as byte[2]
    dim reqResult as byte
    bufferSize=2

    ' Reset baud rates
    PCD_WriteRegister(TxModeReg, 0x00)
    PCD_WriteRegister(RxModeReg, 0x00)
    ' Reset ModWidthReg
    PCD_WriteRegister(ModWidthReg, 0x26)


    reqResult = PICC_RequestA(@bufferATQA, @bufferSize)
    result = ((reqResult = STATUS_OK) or (reqResult = STATUS_COLLISION) )
  end sub

end.